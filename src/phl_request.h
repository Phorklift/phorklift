#ifndef PHL_REQUEST_H
#define PHL_REQUEST_H

struct phl_request;

#include "phl_module.h"
#include "phl_header.h"
#include "phl_conf.h"
#include "phl_connection.h"

#define PHL_CONTENT_LENGTH_INIT		SIZE_MAX

struct phl_request {
	struct {
		enum wuy_http_method	method;
		int			version;
		size_t			content_length;

		struct {
			const char	*raw;
			const char	*path;
			bool		is_rewrited;

			const char	*path_pos;
			const char	*query_pos;
			int		path_len;
			int		query_len;
		} uri;

		const char		*host;
		wuy_slist_t		headers;

		wuy_http_chunked_t	chunked;

		uint8_t			*body_buf;
		int			body_len;
		bool			body_finished;
	} req;

	struct {
		enum wuy_http_status_code  status_code;
		int			version;
		wuy_slist_t		headers;

		size_t			content_length; /* set by content module, and may be changed by any filter module later */

		size_t			content_original_length; /* original length set by content module */
		size_t			content_generated_length; /* the length of body generated by content module */

		size_t			sent_length; /* only for log and stats */

		const char		*easy_string;
		int			easy_fd;
	} resp;

	enum {
		PHL_REQUEST_STATE_RECEIVE_HEADERS = 0,
		PHL_REQUEST_STATE_LOCATE_CONF_HOST,
		PHL_REQUEST_STATE_LOCATE_CONF_PATH,
		PHL_REQUEST_STATE_RECEIVE_BODY_SYNC,
		PHL_REQUEST_STATE_PROCESS_HEADERS,
		PHL_REQUEST_STATE_PROCESS_BODY,
		PHL_REQUEST_STATE_RESPONSE_HEADERS_1,
		PHL_REQUEST_STATE_RESPONSE_HEADERS_2,
		PHL_REQUEST_STATE_RESPONSE_HEADERS_3,
		PHL_REQUEST_STATE_RESPONSE_BODY,
		PHL_REQUEST_STATE_DONE,
	} state;

	uint32_t		id;

	bool			closed;
	bool			is_broken; //TODO may put in phl_request_run()?

	int			redirects;

	int			filter_indexs[3];
	const struct phl_module	*filter_terminal;

	long			create_time;
	long			req_end_time;
	long			resp_begin_time;

	const char		*named_path;

	struct phl_dynamic_ctx	*dynamic_ctx;

	lua_State		*L;
	wuy_cflua_function_t	current_entry;

	struct phl_request	*father; /* of subrequest */
	wuy_list_t		subr_head;

	wuy_list_node_t		list_node;

	http2_stream_t		*h2s;

	struct phl_connection	*c;

	struct phl_conf_host	*conf_host;
	struct phl_conf_path	*conf_path;

	wuy_pool_t		*pool;

	/* #module_ctxs should be $phl_module_number.
	 * However it's not known in compiling because of dynamic
	 * modules, so set 0 by now. */
	void 			*module_ctxs[0];
};

struct phl_request *phl_request_new(struct phl_connection *c);
void phl_request_close(struct phl_request *r);

bool phl_request_set_uri(struct phl_request *r, const char *uri_str, int uri_len);
bool phl_request_set_host(struct phl_request *r, const char *host_str, int host_len);
int phl_request_append_body(struct phl_request *r, const void *buf, int len);

void phl_request_reset_response(struct phl_request *r);

int phl_request_redirect(struct phl_request *r, const char *path);

void phl_request_run(struct phl_request *r, const char *from);

void phl_request_init(void);

struct phl_request *phl_request_subr_new(struct phl_request *father, const char *uri);
void phl_request_subr_detach(struct phl_request *subr);
void phl_request_subr_close(struct phl_request *subr);

int phl_request_subr_flush_connection(struct phl_connection *c);

void phl_request_response_internal_error(struct phl_request *r, const char *fmt, ...);

#define phl_request_do_log(r, log, level, fmt, ...) \
	do { \
		const char *_uri = (level >= PHL_LOG_ERROR) ? r->req.uri.raw : "-"; \
		phl_log_level(log, level, "%lu:%u %s " fmt, r->c->id, r->id, _uri, ##__VA_ARGS__); \
		if (level == PHL_LOG_ERROR && r->conf_path->response_internal_error) \
			phl_request_response_internal_error(r, "INTERNAL ERROR: " fmt "\n", ##__VA_ARGS__); \
	} while(0)

#define phl_request_log(r, level, fmt, ...) \
	phl_request_do_log(r, r->conf_path->error_log, level, fmt, ##__VA_ARGS__)

#define phl_request_log_at(r, log, level, fmt, ...) \
	do { \
		struct phl_log *_log = log ? log : r->conf_path->error_log; \
		phl_request_do_log(r, _log, level, fmt, ##__VA_ARGS__); \
	} while(0)

#endif
